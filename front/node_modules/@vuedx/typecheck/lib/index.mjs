import { invariant, flatten, collectError, collect, Telemetry } from '@vuedx/shared';
import glob from 'fast-glob';
import * as FS from 'fs';
import FS__default, { promises } from 'fs';
import * as Path from 'path';
import * as TS from 'typescript/lib/tsserverlibrary';
import TS__default from 'typescript/lib/tsserverlibrary';
import { fork } from 'child_process';
import readline, { createInterface } from 'readline';
import resolveFrom from 'resolve-from';
import chalk from 'chalk';
import parseArgs from 'minimist';

var version = "0.7.6";

function resolve(moduleId, directory) {
    try {
        return resolveFrom(directory, moduleId);
    }
    catch {
        return require.resolve(moduleId);
    }
}
process.env['DEBUG'] != null;
function debug(...args) {
}
class TypeScriptServerHost {
    constructor() {
        this.voidCommands = [
            'open',
            'geterr',
            'geterrForProject',
        ];
        this.serverPath = resolve('typescript/lib/tsserver', process.cwd());
        this.pluginPath = Path.resolve(Path.dirname(require.resolve('@vuedx/typescript-plugin-vue/package.json')), '../..');
        this.isClosed = false;
        this.pendingResponses = 0;
        this.responseHandlers = new Map();
        this._messageId = 0;
        this.eventHandlers = {};
        // prettier-ignore
        const debugArgs = process.env['DEBUG_TS_SERVER'] != null
            ? [
                '--logVerbosity', 'verbose',
                '--logFile', process.env['TS_SERVER_LOG_FILE'] ?? 'tsserver.log',
            ]
            : [];
        // prettier-ignore
        this.server = fork(this.serverPath, [
            ...debugArgs,
            '--globalPlugins', '@vuedx/typescript-plugin-vue',
            '--pluginProbeLocations', `${process.cwd()},${this.pluginPath}`,
            '--allowLocalPluginLoads',
            '--useSingleInferredProject'
        ], {
            cwd: process.cwd(),
            stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
            execArgv: process.env['TS_SERVER_INSPECT'] != null ? ['--inspect'] :
                process.env['TS_SERVER_INSPECT_BRK'] != null ? ['--inspect-brk=9229'] :
                    []
        });
        this.exitStatus = new Promise((resolve) => {
            let isResolved = false;
            this.server.on('exit', (code) => {
                if (!isResolved)
                    resolve(code ?? 0);
            });
            this.server.on('error', (error) => {
                isResolved = true;
                console.error(error);
                resolve(-1);
            });
        });
        if (this.server.stdout == null)
            throw new Error('No stdout');
        if (this.server.stdin == null)
            throw new Error('No stdin');
        this.stdout = this.server.stdout;
        this.stdin = this.server.stdin;
        this.stdout.setEncoding('utf-8');
        this.readline = createInterface({ input: this.stdout });
        this.readline.on('line', (line) => {
            if (line.startsWith('{')) {
                const payload = JSON.parse(line);
                if (payload.type === 'response') {
                    this.pendingResponses -= 1;
                    this.responseHandlers.get(payload.request_seq)?.(payload);
                }
                else if (payload.type === 'request') ;
                else if (payload.type === 'event') {
                    this.onEvent(payload);
                }
                if (this.isClosed) {
                    this.shutdown();
                }
            }
        });
    }
    getNextMessageId() {
        return this._messageId++;
    }
    onEvent(payload) {
        this.eventHandlers[payload.event]?.forEach((fn) => fn(payload.body));
    }
    send(message) {
        if (this.isClosed) {
            throw new Error('Cannot send messages to a closed server connection.');
        }
        const seq = this.getNextMessageId();
        const payload = { seq, ...message };
        this.stdin.write(JSON.stringify(payload) + '\n');
        return seq;
    }
    on(event, fn) {
        const handlers = this.eventHandlers[event] ?? (this.eventHandlers[event] = []);
        handlers.push(fn);
        return () => {
            const index = handlers.indexOf(fn);
            if (index >= 0) {
                handlers.splice(index, 1);
            }
        };
    }
    async sendRequest(request) {
        const id = this.send({ type: 'request', ...request });
        if (!this.voidCommands.includes(request.command)) {
            this.pendingResponses += 1;
            return await new Promise((resolve) => {
                this.responseHandlers.set(id, (response) => resolve(response));
            });
        }
        else {
            return id;
        }
    }
    sendEvent(event) {
        this.send({ type: 'event', ...event });
    }
    async close() {
        this.isClosed = true;
        this.shutdown();
        return await this.exitStatus;
    }
    shutdown() {
        if (this.pendingResponses <= 0) {
            this.stdin.end();
        }
        else {
            debug(`shutting after ${this.pendingResponses}...`);
        }
    }
    async sendCommand(command, args) {
        return this.sendRequest({ command, arguments: args });
    }
}

function toNormalizedPath$1(fileName) {
    return TS.server.toNormalizedPath(fileName);
}
class AbortSignal {
    constructor() {
        this._aborted = false;
    }
    get aborted() {
        return this._aborted;
    }
    // eslint-disable-next-line accessor-pairs
    set onabort(fn) {
        this._onabort = fn;
    }
    async dispatchEvent(_event) {
        this._aborted = true;
        return await this._onabort?.();
    }
}
class AbortController {
    constructor() {
        this.signal = new AbortSignal();
    }
    async abort() {
        // @ts-expect-error
        return await this.signal.dispatchEvent('aborted');
    }
}
async function* getDiagnosticsStream(directory, cancellationToken, logging = false, filter = () => true) {
    const debug = logging ? console.debug : () => { };
    const host = new TypeScriptServerHost();
    if (cancellationToken != null) {
        cancellationToken.onabort = async () => {
            await host.close();
        };
    }
    const projectRootPath = toNormalizedPath$1(directory);
    const diagnosticsPerFile = new Map();
    function setDiagnostics(fileName, kind, diagnostics) {
        debug(`[diagnostics] ${kind} ${fileName}`);
        const current = {
            ...(diagnosticsPerFile.get(fileName) ?? {}),
            [kind]: diagnostics,
        };
        diagnosticsPerFile.set(fileName, current);
        if (current.semantic != null &&
            current.syntax != null &&
            current.suggestion != null) {
            const all = merge(current.semantic, current.syntax, current.suggestion);
            if (all.length > 0) {
                results.push({ fileName, diagnostics: all });
                debug(`Completed ${fileName}. ${all.length} issue(s).`);
            }
            else {
                debug(`Completed ${fileName}. No issues.`);
            }
            pending.delete(fileName);
        }
    }
    const pack = () => Array.from(diagnosticsPerFile.entries())
        .map(([fileName, diagnostics]) => ({
        fileName,
        diagnostics: merge(diagnostics.semantic, diagnostics.suggestion, diagnostics.syntax),
    }))
        .filter((item) => item.diagnostics.length > 0);
    await host.sendCommand('configure', {
        hostInfo: '@vuedx/typecheck',
        preferences: { disableSuggestions: false },
    });
    let files;
    let projectFileName;
    const jsConfig = Path.resolve(directory, 'jsconfig.json');
    const tsConfig = Path.resolve(directory, 'tsconfig.json');
    if (FS.existsSync(tsConfig) || FS.existsSync(jsConfig)) {
        projectFileName = FS.existsSync(tsConfig) ? tsConfig : jsConfig;
        debug('Using project', projectFileName);
        await host.sendCommand('updateOpen', {
            openFiles: [
                {
                    file: toNormalizedPath$1(projectFileName),
                    projectRootPath,
                },
            ],
        });
        const { body } = await host.sendCommand('projectInfo', {
            file: toNormalizedPath$1(projectFileName),
            projectFileName: toNormalizedPath$1(projectFileName),
            needFileNameList: true,
        });
        invariant(body != null, 'Project info is null.');
        invariant(body.fileNames != null, 'Project has no files.');
        files = body.fileNames.filter((fileName) => {
            if (fileName.includes('/node_modules/') ||
                fileName.endsWith('.json') ||
                fileName.endsWith('.vue.tsx') ||
                fileName.endsWith('.vue.jsx')) {
                return false;
            }
            return filter(fileName);
        });
    }
    else {
        await host.sendCommand('compilerOptionsForInferredProjects', {
            options: {
                allowJs: true,
                checkJs: true,
                strict: true,
                alwaysStrict: true,
                allowNonTsExtensions: true,
                jsx: 'preserve',
            },
        });
        files = (await glob(['**/*.vue', '**/*.ts', '**/*.js', '**/*.jsx', '**/*.tsx'], {
            cwd: directory,
            absolute: true,
            ignore: ['node_modules', 'dist'],
        }))
            .filter(filter)
            .map((fileName) => toNormalizedPath$1(fileName));
        debug('Using inferred project', directory);
    }
    debug(`found ${files.length} files`);
    host.on('semanticDiag', (event) => {
        setDiagnostics(event.file, 'semantic', event.diagnostics);
    });
    host.on('syntaxDiag', (event) => {
        setDiagnostics(event.file, 'syntax', event.diagnostics);
    });
    host.on('suggestionDiag', (event) => {
        setDiagnostics(event.file, 'suggestion', event.diagnostics);
    });
    const pending = new Set(files);
    const results = [];
    void Promise.all(files.map(async (file) => {
        await host.sendCommand('updateOpen', {
            openFiles: [
                {
                    file,
                    projectRootPath,
                    projectFileName,
                },
            ],
        });
        await host.sendCommand('geterr', { files, delay: 1 });
    }));
    while (cancellationToken == null ? pending.size > 0 : !cancellationToken.aborted) {
        const result = results.shift();
        if (result != null) {
            debug(`Yielding ${result.fileName}`);
            yield result;
        }
        if (pending.size === 0)
            break;
        else {
            debug(`Waiting for ${pending.size} files`);
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
    }
    debug(`Done.`);
    await host.close();
    return pack();
}
async function getDiagnostics$1(directory) {
    const stream = getDiagnosticsStream(directory, null, process.env['DEBUG'] != null);
    let next;
    while ((next = await stream.next()).done === false)
        ;
    invariant(next.done === true, 'Stream should be done.');
    return next.value;
}
function merge(...items) {
    return flatten(items.map((item) => item ?? []));
}

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
class FullTextDocument {
    constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            const start = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(changes, version) {
        for (let change of changes) {
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                const range = getWellformedRange(change.range);
                // update content
                const startOffset = this.offsetAt(range.start);
                const endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                const startLine = Math.max(range.start.line, 0);
                const endLine = Math.max(range.end.line, 0);
                let lineOffsets = this._lineOffsets;
                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                const diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
    static isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    static isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
}
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        let text = document.getText();
        let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
            let diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
            let startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    const p = (data.length / 2) | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        let ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text.length; i++) {
        let ch = text.charCodeAt(i);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range };
    }
    return textEdit;
}

function generateCodeFrame(source, start = 0, end = source.length, underline = (str) => str, gutter = (str) => str, range = 2) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    const width = String(lines.length).length;
    const getLine = (line) => String(line).padStart(width) + ' | ';
    for (let i = 0; i < lines.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                res.push(`${gutter(getLine(line))}${lines[j]}`);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(gutter(getLine('')) +
                        ' '.repeat(pad) +
                        underline('~'.repeat(length)));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(gutter(getLine('')) + underline('~'.repeat(length)));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

const colors = {
    warning: chalk.yellow,
    error: chalk.red,
    suggestion: chalk.green,
    message: chalk.blueBright,
};
let directory = process.cwd();
const cache = new Map();
function print(chunk) {
    process.stdout.write(chunk);
}
async function getTextDocument(file) {
    return cache.get(file) ?? (await createTextDocument(file));
}
function clearScreen() {
    const blank = '\n'.repeat(process.stdout.rows);
    console.log(blank);
    readline.cursorTo(process.stdout, 0, 0);
    readline.clearScreenDown(process.stdout);
}
async function createTextDocument(file) {
    const content = await promises.readFile(Path.resolve(directory, file), {
        encoding: 'utf-8',
    });
    const fileName = toNormalizedPath(file);
    const document = TextDocument.create(fileName, Path.posix.extname(file), 0, content);
    cache.set(fileName, document);
    return document;
}
function toNormalizedPath(fileName) {
    return TS__default.server.toNormalizedPath(fileName);
}
function formatLocation(fileName, start) {
    const relativeFileName = convertToRelativePath(fileName);
    const line = start.line;
    const column = start.offset;
    let output = '';
    output += chalk.cyan(relativeFileName);
    output += ':';
    output += chalk.yellow(`${line}`);
    output += ':';
    output += chalk.yellow(`${column}`);
    return output;
}
function getDiagnosticCategory(diagnostic) {
    return (/^(warning|error|suggestion|message)$/i.test(diagnostic.category)
        ? diagnostic.category.toLowerCase()
        : 'error');
}
function toPosition(loc) {
    return { line: loc.line - 1, character: loc.offset - 1 };
}
async function formatDiagnosticsWithColorAndContext(fileName, diagnostic) {
    let output = '';
    output += formatLocation(fileName, diagnostic.start); // TODO: GH#18217
    output += ' - ';
    const category = getDiagnosticCategory(diagnostic);
    output += colors[category](category);
    output += chalk.gray(` ${diagnostic.source ?? ''}${diagnostic.code ?? ''}: `);
    output += diagnostic.text;
    const document = await getTextDocument(fileName);
    output += '\n';
    output += generateCodeFrame(document.getText(), document.offsetAt(toPosition(diagnostic.start)), document.offsetAt(toPosition(diagnostic.end)), (underline) => colors[category](underline), (gutter) => chalk.bgWhite(gutter.trimEnd()) + ' ');
    if (diagnostic.relatedInformation != null) {
        for (const { message, span, category } of diagnostic.relatedInformation) {
            output += '\n';
            const color = colors[getDiagnosticCategory({ category })];
            if (span != null) {
                output += '    ' + formatLocation(span.file, span.start);
                const document = await getTextDocument(span.file);
                output += '\n';
                output += generateCodeFrame(document.getText(), document.offsetAt(toPosition(span.start)), document.offsetAt(toPosition(span.end)), (underline) => color(underline), (gutter) => chalk.bgWhite(gutter.trimEnd()) + ' ');
                output += '\n';
            }
            output += '    ' + message;
        }
    }
    output += '\n';
    return output;
}
function formatDiagnostic(fileName, diagnostic) {
    const errorMessage = `${diagnostic.category} ${diagnostic.source ?? ''}${diagnostic.code ?? ''}: ${diagnostic.text}`;
    const relativeFileName = convertToRelativePath(fileName);
    const line = diagnostic.start.line + 1;
    const column = diagnostic.start.offset + 1;
    return `${relativeFileName}(${line},${column}): ${errorMessage}`;
}
const ERROR_RE = /^(error)$/i;
function getErrorCount(diagnostics) {
    return diagnostics.reduce((count, diagnostic) => count +
        diagnostic.diagnostics.filter((diagnostic) => ERROR_RE.test(diagnostic.category)).length, 0);
}
function convertToRelativePath(fileName) {
    return Path.isAbsolute(fileName)
        ? Path.relative(directory, fileName).replace(/\\/g, '/')
        : fileName;
}
async function _cli() {
    const { pretty, vue, help, watch, format, _: argv, } = parseArgs(process.argv.slice(2), {
        boolean: ['json', 'rdjson', 'verbose', 'vue', 'help', 'pretty', 'watch'],
        string: ['format'],
        default: { pretty: true, format: 'raw' },
    });
    if (help === true) {
        console.error(`
Usage: vuedx-typecheck [directory] <options>

Options
    --format    One of 'raw', 'json' or 'rdjson'
    --vue       process only vue files
    --no-pretty Pretty print output
    --help      display help
    --watch     Watch files for changes
`.trim());
        process.exit(0);
    }
    directory =
        argv[0] != null
            ? Path.isAbsolute(argv[0])
                ? argv[0]
                : Path.resolve(process.cwd(), argv[0])
            : process.cwd();
    if (!FS__default.existsSync(directory)) {
        console.error(`Cannot find directory: "${String(argv[0])}"`);
        process.exit(1);
    }
    if (format === 'raw') {
        console.debug('Running for ' + directory);
    }
    if (!FS__default.statSync(directory).isDirectory()) {
        console.error(`Expecting a directory, but "${process.argv[2] ?? ''}" is not a directory.`);
        process.exit(1);
    }
    collect('cli exec', {
        watch,
        format,
        vue,
        pretty,
    });
    const controller = new AbortController();
    const cursor = getDiagnosticsStream(directory, watch === true ? controller.signal : null, process.env['DEBUG'] != null, vue === true ? (fileName) => fileName.endsWith('.vue') : undefined);
    let result;
    while ((result = await cursor.next()).done !== true) {
        if (format === 'raw') {
            await handleResults([result.value], { format, pretty, vue });
        }
    }
    invariant(result.done, 'Expected done to be true');
    if (format === 'raw') {
        clearScreen();
    }
    await handleResults(result.value, { format, pretty, vue });
}
async function cli$1() {
    try {
        await _cli();
    }
    catch (error) {
        collectError(error);
        throw error;
    }
}
/**
 * Return diagnostic result in Reviewdog Diagnostic Format
 * @see https://github.com/reviewdog/reviewdog/tree/main/proto/rdf#rdjson
 */
function encodeRdJSON(result, pretty) {
    const severityMap = {
        warning: 'WARNING',
        error: 'ERROR',
        suggestion: 'INFO',
        message: 'INFO',
    };
    return JSON.stringify({
        source: {
            name: 'VueDX typecheck',
            url: 'https://github.com/znck/vue-developer-experience/tree/main/packages/typecheck',
        },
        diagnostics: result.flatMap((sourceFile) => {
            return sourceFile.diagnostics.map((diagnostic) => ({
                message: diagnostic.text,
                severity: severityMap[diagnostic.category],
                location: {
                    path: sourceFile.fileName,
                    range: {
                        start: {
                            line: diagnostic.start.line,
                            column: diagnostic.start.offset,
                        },
                        end: { line: diagnostic.end.line, column: diagnostic.end.offset },
                    },
                },
                code: {
                    value: `${diagnostic.code ?? ''}`,
                },
                relatedInformation: diagnostic.relatedInformation?.map((info) => ({
                    message: info.message,
                    severity: severityMap[info.category],
                    location: info.span != null
                        ? {
                            path: info.span.file,
                            range: {
                                start: {
                                    line: info.span.start.line,
                                    column: info.span.start.offset,
                                },
                                end: {
                                    line: info.span.end.line,
                                    column: info.span.end.offset,
                                },
                            },
                        }
                        : undefined,
                    code: {
                        value: `${info.code ?? ''}`,
                    },
                })),
            }));
        }),
    }, null, pretty ? 2 : 0);
}
async function handleResults(result, { vue, format, pretty, }) {
    if (vue) {
        result = result.filter((item) => item.fileName.endsWith('.vue'));
    }
    result.forEach((sourceFile) => {
        sourceFile.fileName = convertToRelativePath(sourceFile.fileName);
        sourceFile.diagnostics.forEach((diagnostic) => {
            diagnostic.relatedInformation?.forEach((info) => {
                if (info.span != null) {
                    info.span.file = convertToRelativePath(info.span.file);
                }
            });
        });
    });
    switch (format) {
        case 'json':
            print(JSON.stringify(result, null, pretty ? 2 : 0));
            break;
        case 'rdjson':
            print(encodeRdJSON(result, pretty));
            break;
        case 'raw':
            {
                const fn = pretty
                    ? formatDiagnosticsWithColorAndContext
                    : formatDiagnostic;
                const content = await Promise.all(result.flatMap((sourceFile) => sourceFile.diagnostics.map((diagnostic) => fn(sourceFile.fileName, diagnostic))));
                print(content.join('\n'));
                const count = getErrorCount(result);
                print(`\nFound ${count} ${count === 1 ? 'error' : 'errors'}.\n`);
            }
            break;
        default:
            throw new Error(`Unknown output format: "${format}"`);
    }
}

async function cli() {
    setup();
    return await cli$1();
}
async function getDiagnostics(directory) {
    setup();
    try {
        return await getDiagnostics$1(directory);
    }
    catch (error) {
        collectError(error);
        return [];
    }
}
function setup() {
    Telemetry.setup('https://212f65f46796440ebbe974f24b20ffae@o237831.ingest.sentry.io/5595698', 'typecheck', version, process.env['CI'] != null ? 1 : 0.25, {
        ci: process.env['CI'],
    });
}

export { cli, getDiagnostics };
//# sourceMappingURL=index.mjs.map
